=== LANGUAGE: HTTP (Requests & Responses) ===

WHAT IS HTTP?
HTTP (HyperText Transfer Protocol) is the foundation of client-server communication on the web.
- Clients (browsers, curl) send requests; servers respond with responses.
- Stateless: each request is independent; no session data is retained unless implemented via cookies.
- Webserv must handle HTTP/1.1, including:
    - Multiple clients
    - Parsing requests
    - Generating valid responses
    - Handling persistent connections

KEY CONCEPTS:
- Request-Line: <METHOD> <URI> HTTP/<VERSION>
- Headers: metadata (Host, Content-Length, Connection)
- Body: optional, usually for POST/PUT
- Status codes: 200, 404, 500, etc.
- Persistent connections: "Connection: keep-alive" vs "close"

---

HEADERS / IMPORTS:
#include <string>
#include <map>
#include <sstream>
#include <iostream>

---

DECLARATION / SYNTAX:
struct HttpRequest {
    std::string method;
    std::string uri;
    std::string version;
    std::map<std::string, std::string> headers;
    std::string body;
};

struct HttpResponse {
    std::string version;
    int status_code;
    std::string reason;
    std::map<std::string, std::string> headers;
    std::string body;
};

---

PARAMETERS / DETAILS:
HTTP Request:
- method: GET, POST, DELETE, HEAD
- uri: resource path (/index.html)
- version: HTTP/1.1
- headers: key-value pairs (case-insensitive)
- body: optional, used with POST/PUT

HTTP Response:
- version: HTTP version
- status_code: numeric code (200, 404…)
- reason: textual explanation ("OK", "Not Found")
- headers: key-value metadata
- body: content sent to client

---

BASIC REQUEST PARSING EXAMPLE:
std::string raw = "GET /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n";
std::istringstream stream(raw);
HttpRequest req;
stream >> req.method >> req.uri >> req.version;

std::string line;
while (std::getline(stream, line) && line != "\r") {
    size_t sep = line.find(":");
    if (sep != std::string::npos)
        req.headers[line.substr(0, sep)] = line.substr(sep + 2, line.size() - sep - 3);
}

BASIC RESPONSE BUILD EXAMPLE:
HttpResponse res;
res.version = "HTTP/1.1";
res.status_code = 200;
res.reason = "OK";
res.headers["Content-Type"] = "text/html";
res.body = "<h1>Hello World</h1>";
res.headers["Content-Length"] = std::to_string(res.body.size());

std::ostringstream out;
out << res.version << " " << res.status_code << " " << res.reason << "\r\n";
for(auto it = res.headers.begin(); it != res.headers.end(); ++it)
    out << it->first << ": " << it->second << "\r\n";
out << "\r\n" << res.body;

std::string response_str = out.str();

---

ADVANCED CONSIDERATIONS:
- Persistent connections: handle "Connection: keep-alive" vs "close"
- Partial reads: POST body may arrive in multiple TCP packets; buffer until complete
- Chunked encoding: optional for large responses
- Header parsing: case-insensitive keys, trim whitespaces
- Content-Length: must match body size or client may hang
- Multiple clients: combine with select() or poll() for concurrency
- Request validation: reject invalid methods, malformed lines

---

GOTCHAS:
- Missing \r\n → malformed request/response
- Content-Length mismatch → client hangs
- POST body split across multiple recv() calls → loop until complete
- Header names case-insensitive → normalize before lookup
- Connection may close unexpectedly → handle gracefully

---

42 SPECIFIC NOTES:
- Support GET, POST, DELETE at minimum
- Manual parsing required; no external HTTP libraries
- Functions <25 lines (norm compliance)
- Correct status codes: 404, 400, 500
- Must handle multiple clients concurrently
- Optional: implement chunked transfer for large POST/response bodies
- Persistent connections: handle multiple requests on same TCP session

---

CPP98 CONSTRAINTS:
- Use std::map for headers; no unordered_map
- Manual loops; no auto or range-based for
- No std::string_view; use substrings

---

RELATED CONCEPTS:
- Sockets, select, poll
- recv()/send() functions and buffer management
- HTTP status codes, methods, headers
- Webserv core modules and norm compliance

