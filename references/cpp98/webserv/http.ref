=== LANGUAGE: HTTP (Requests & Responses) ===

WHAT IS HTTP?
HTTP (HyperText Transfer Protocol) is the protocol used for client-server communication on the web.
Webserv must handle HTTP/1.1 requests and responses for multiple clients simultaneously.
Key points:
- Stateless: each request is independent.
- Request → Response: client sends request, server parses it, responds.
- Headers: key-value metadata about the request/response.
- Body: optional data payload (POST, PUT).
- Persistent connections: "Connection: keep-alive" allows multiple requests per TCP session.

---

HTTP REQUESTS

STRUCTURE:
<Request-Line>\r\n
Header-Name: Header-Value\r\n
...
\r\n
[Optional body]

<Request-Line> = <METHOD> <URI> HTTP/<VERSION>

COMMON METHODS:
- GET    → retrieve a resource, no body
- POST   → submit data to server, body included
- DELETE → remove resource
- HEAD   → like GET, no body
- Optional: PUT, PATCH, OPTIONS

PARAMETERS & MEANING:
- Method → action client wants (GET, POST…)
- URI → resource path (/index.html)
- Version → HTTP/1.0, HTTP/1.1
- Headers → metadata (Host, Content-Length, Connection…)
- Body → optional data for POST/PUT

BASIC PARSING EXAMPLE:
std::string raw = "GET /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n";
std::istringstream stream(raw);
HttpRequest req;
stream >> req.method >> req.uri >> req.version;

std::string line;
while(std::getline(stream, line) && line != "\r") {
    size_t sep = line.find(":");
    if(sep != std::string::npos)
        req.headers[line.substr(0, sep)] = line.substr(sep + 2, line.size() - sep - 3);
}

---

HTTP RESPONSES

STRUCTURE:
HTTP/<VERSION> <STATUS_CODE> <REASON_PHRASE>\r\n
Header-Name: Header-Value\r\n
...
\r\n
[Body]

COMMON STATUS CODES:
- 200 OK → success
- 201 Created → resource created (POST)
- 400 Bad Request → malformed request
- 404 Not Found → resource missing
- 405 Method Not Allowed → unsupported method
- 500 Internal Server Error → server error

BASIC RESPONSE EXAMPLE:
HttpResponse res;
res.version = "HTTP/1.1";
res.status_code = 200;
res.reason = "OK";
res.headers["Content-Type"] = "text/html";
res.body = "<h1>Hello World</h1>";
res.headers["Content-Length"] = std::to_string(res.body.size());

std::ostringstream out;
out << res.version << " " << res.status_code << " " << res.reason << "\r\n";
for(auto it = res.headers.begin(); it != res.headers.end(); ++it)
    out << it->first << ": " << it->second << "\r\n";
out << "\r\n" << res.body;

std::string response_str = out.str();

---

ADVANCED CONSIDERATIONS

- Persistent connections: handle "Connection: keep-alive" vs "close".
- Partial reads: POST body may arrive in multiple TCP packets → buffer until complete.
- Chunked encoding: optional in 42, used for streaming large bodies.
- Header parsing: case-insensitive keys, trim spaces.
- Content-Length: must match body size or client hangs.
- Multiple clients: combine with select() or poll() for concurrency.

---

GOTCHAS

- Forgetting \r\n → malformed request/response.
- Content-Length mismatch → client hangs.
- POST body split across multiple recv() calls → must loop.
- Headers can arrive in multiple TCP packets → accumulate buffer.
- Connection may close unexpectedly → handle gracefully.

---

42 SPECIFIC NOTES

- Support GET, POST, DELETE at minimum.
- Use manual parsing; no external libraries.
- Split functions <25 lines for norm compliance.
- Properly handle multiple clients concurrently.
- Return correct status codes (404, 400, 500).
- Optional: implement chunked transfer for POST/large responses.
- Must handle persistent connections correctly.

---

CPP98 CONSTRAINTS

- Use std::map for headers, not unordered_map.
- Manual loops; no auto or range-based for.
- No std::string_view; use substr() for string slices.

---

RELATED CONCEPTS

- Sockets, select, poll, TCP communication.
- HTTP status codes and methods.
- recv()/send() functions and buffer handling.
- Webserv multi-client handling and norm compliance.

