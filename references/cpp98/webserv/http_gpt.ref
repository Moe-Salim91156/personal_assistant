=== HTTP.TXT: THEORY, USAGE, WEBSERV CONTEXT ===

WHAT IS HTTP?
Hypertext Transfer Protocol (HTTP) is the core protocol for communication on the Web. It defines how clients (browsers) and servers exchange messages.

HTTP 1.1 (used in Webserv) is stateless but supports:

* Persistent connections (multiple requests/responses per TCP connection)
* Chunked transfer encoding (sending response in pieces)

---

THEORY / DEEP DIVE:

* HTTP messages are plain text, ASCII-encoded.
* Request Structure:

  1. Request Line: METHOD PATH VERSION (e.g., GET /index.html HTTP/1.1)
  2. Headers: key: value pairs (Host, User-Agent, Content-Length, etc.)
  3. Empty line
  4. Optional body (mainly POST/PUT)
* Response Structure:

  1. Status Line: VERSION STATUS_CODE REASON_PHRASE (e.g., HTTP/1.1 200 OK)
  2. Headers: Content-Type, Content-Length, Connection, etc.
  3. Empty line
  4. Body: HTML, JSON, text, binary

HTTP METHODS:

* GET: Retrieve resource
* POST: Send data to server
* HEAD: Retrieve only headers
* DELETE: Remove resource
* OPTIONS: Query server capabilities

STATUS CODES:

* 1xx: Informational
* 2xx: Success (200 OK)
* 3xx: Redirection
* 4xx: Client Error (404 Not Found, 405 Method Not Allowed)
* 5xx: Server Error (500 Internal Server Error)

IMPORTANT HEADERS:

* Host: Specifies server
* Content-Length: Length of body in bytes
* Content-Type: MIME type
* Connection: keep-alive / close
* Transfer-Encoding: chunked

PERSISTENT CONNECTIONS:

* Keep connection open for multiple requests/responses
* Improves performance by avoiding TCP handshake for each request

CHUNKED TRANSFER:

* Send response in chunks of unknown size
* Format: <chunk-size in hex>\r\n<data>\r\n
* Ends with chunk-size 0\r\n\r\n

---

SMALL IMPLEMENTATION EXAMPLES:
// Parsing request line
std::string request_line = "GET /index.html HTTP/1.1";
std::istringstream iss(request_line);
std::string method, path, version;
iss >> method >> path >> version;

// Sending simple response
const char* response = "HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, world!";
send(client_fd, response, strlen(response), 0);

//------------------------------------------------------------
WEBSERV CONTEXT / USAGE:

* Parse request line + headers + optional body
* Store headers in map<string,string> for quick access
* Handle multiple clients with select() or poll()
* GET: serve static files from root directory
* POST: forward to CGI scripts with CONTENT_LENGTH handling
* Handle errors: 404, 405, 413, 500
* Use chunked encoding for dynamic content
* Correct HTTP formatting is mandatory for norm compliance

NERDY NOTES:

* HTTP is stateless: maintain state via cookies or sessions if needed
* CRLF injections/malformed headers must be sanitized
* Always validate method, path, version
* Large POST: read exactly Content-Length bytes
* Non-blocking recv() may require looping to assemble full request
* Implement minimal timeout for persistent connections

RELATED CONCEPTS:

* TCP sockets, non-blocking I/O, select(), poll(), CGI execution
* std::vector for client management
* String parsing utilities: substr, find, map

=== END OF HTTP.TXT ===

